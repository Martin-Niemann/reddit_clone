// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const checkForExistingUser = `-- name: CheckForExistingUser :one
SELECT EXISTS(SELECT 1 FROM reddit_clone.users WHERE email = ? OR user_name = ?)
`

type CheckForExistingUserParams struct {
	Email    string `json:"email"`
	UserName string `json:"user_name"`
}

func (q *Queries) CheckForExistingUser(ctx context.Context, arg CheckForExistingUserParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkForExistingUser, arg.Email, arg.UserName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCommentOnParent = `-- name: CreateCommentOnParent :execresult
INSERT INTO reddit_clone.comments (
    comment, id_post, parent_id, id_user, is_toplevel
) VALUES (
    ?, ?, ?, ?, false
)
`

type CreateCommentOnParentParams struct {
	Comment  string `json:"comment"`
	IDPost   int32  `json:"id_post"`
	ParentID *int32 `json:"parent_id"`
	IDUser   int32  `json:"id_user"`
}

func (q *Queries) CreateCommentOnParent(ctx context.Context, arg CreateCommentOnParentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCommentOnParent,
		arg.Comment,
		arg.IDPost,
		arg.ParentID,
		arg.IDUser,
	)
}

const createCommentOnPost = `-- name: CreateCommentOnPost :execresult
INSERT INTO reddit_clone.comments (
    comment, id_post, id_user, is_toplevel
) VALUES (
    ?, ?, ?, true
)
`

type CreateCommentOnPostParams struct {
	Comment string `json:"comment"`
	IDPost  int32  `json:"id_post"`
	IDUser  int32  `json:"id_user"`
}

func (q *Queries) CreateCommentOnPost(ctx context.Context, arg CreateCommentOnPostParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createCommentOnPost, arg.Comment, arg.IDPost, arg.IDUser)
}

const createPost = `-- name: CreatePost :execresult
INSERT INTO reddit_clone.posts (
    title, link, text, id_subreddit, id_user
) VALUES (
    ?, ?, ?, ?, ?
)
`

type CreatePostParams struct {
	Title       string  `json:"title"`
	Link        *string `json:"link"`
	Text        *string `json:"text"`
	IDSubreddit int32   `json:"id_subreddit"`
	IDUser      int32   `json:"id_user"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createPost,
		arg.Title,
		arg.Link,
		arg.Text,
		arg.IDSubreddit,
		arg.IDUser,
	)
}

const createSubreddit = `-- name: CreateSubreddit :execresult
INSERT INTO reddit_clone.subreddits (
    url, name, description, id_user
) VALUES (
    ?, ?, ?, ?
)
`

type CreateSubredditParams struct {
	Url         string  `json:"url"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
	IDUser      *int32  `json:"id_user"`
}

func (q *Queries) CreateSubreddit(ctx context.Context, arg CreateSubredditParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createSubreddit,
		arg.Url,
		arg.Name,
		arg.Description,
		arg.IDUser,
	)
}

const createUser = `-- name: CreateUser :execresult

INSERT INTO reddit_clone.users (
    user_name, email, hashed_password
) VALUES (
    ?, ?, ?
)
`

type CreateUserParams struct {
	UserName       string `json:"user_name"`
	Email          string `json:"email"`
	HashedPassword string `json:"hashed_password"`
}

// -------------------------------------------------- --
// Users
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createUser, arg.UserName, arg.Email, arg.HashedPassword)
}

const deletePost = `-- name: DeletePost :execresult
DELETE FROM reddit_clone.posts
WHERE id_post = ?
`

func (q *Queries) DeletePost(ctx context.Context, idPost int32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deletePost, idPost)
}

const deleteUser = `-- name: DeleteUser :execresult
DELETE FROM reddit_clone.users
WHERE id_user = ?
`

func (q *Queries) DeleteUser(ctx context.Context, idUser int32) (sql.Result, error) {
	return q.db.ExecContext(ctx, deleteUser, idUser)
}

const getCommentById = `-- name: GetCommentById :one

SELECT 
comments.id_comment,
comments.parent_id,
comments.created_at,
comments.updated_at,
comments.comment,
users.user_name,
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = TRUE AND scores.id_comment = comments.id_comment) -
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = FALSE AND scores.id_comment = comments.id_comment)
AS score
FROM reddit_clone.comments AS comments
JOIN (reddit_clone.users AS users)
ON (users.id_user = comments.id_user)
WHERE comments.id_comment = ?
`

type GetCommentByIdRow struct {
	IDComment int32      `json:"id_comment"`
	ParentID  *int32     `json:"parent_id"`
	CreatedAt time.Time  `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	Comment   string     `json:"comment"`
	UserName  string     `json:"user_name"`
	Score     int32      `json:"score"`
}

// -------------------------------------------------- --
// Comment
func (q *Queries) GetCommentById(ctx context.Context, idComment int32) (GetCommentByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getCommentById, idComment)
	var i GetCommentByIdRow
	err := row.Scan(
		&i.IDComment,
		&i.ParentID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Comment,
		&i.UserName,
		&i.Score,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id_user, user_name, email, hashed_password FROM reddit_clone.users
WHERE email = ? LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (RedditCloneUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i RedditCloneUser
	err := row.Scan(
		&i.IDUser,
		&i.UserName,
		&i.Email,
		&i.HashedPassword,
	)
	return i, err
}

const postByIdDetails = `-- name: PostByIdDetails :one

SELECT
posts.id_post,
posts.title,
posts.link,
posts.text,
posts.created_at,
posts.updated_at,
users.user_name,
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = TRUE AND scores.id_post = posts.id_post) -
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = FALSE AND scores.id_post = posts.id_post)
AS score,
subreddits.name
FROM reddit_clone.posts AS posts
JOIN (reddit_clone.users AS users, reddit_clone.subreddits AS subreddits)
ON (users.id_user = posts.id_user AND subreddits.id_subreddit = posts.id_subreddit)
WHERE posts.id_post = ?
`

type PostByIdDetailsRow struct {
	IDPost    int32      `json:"id_post"`
	Title     string     `json:"title"`
	Link      *string    `json:"link"`
	Text      *string    `json:"text"`
	CreatedAt time.Time  `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	UserName  string     `json:"user_name"`
	Score     int32      `json:"score"`
	Name      string     `json:"name"`
}

// -------------------------------------------------- --
// Posts
func (q *Queries) PostByIdDetails(ctx context.Context, idPost int32) (PostByIdDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, postByIdDetails, idPost)
	var i PostByIdDetailsRow
	err := row.Scan(
		&i.IDPost,
		&i.Title,
		&i.Link,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UserName,
		&i.Score,
		&i.Name,
	)
	return i, err
}

const postByIdListComments = `-- name: PostByIdListComments :many
SELECT 
comments.id_comment,
comments.parent_id,
comments.created_at,
comments.updated_at,
comments.comment,
users.user_name,
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = TRUE AND scores.id_comment = comments.id_comment) -
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = FALSE AND scores.id_comment = comments.id_comment)
AS score
FROM reddit_clone.comments AS comments
JOIN (reddit_clone.users AS users)
ON (users.id_user = comments.id_user)
WHERE comments.id_post = ?
`

type PostByIdListCommentsRow struct {
	IDComment int32      `json:"id_comment"`
	ParentID  *int32     `json:"parent_id"`
	CreatedAt time.Time  `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	Comment   string     `json:"comment"`
	UserName  string     `json:"user_name"`
	Score     int32      `json:"score"`
}

func (q *Queries) PostByIdListComments(ctx context.Context, idPost int32) ([]PostByIdListCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, postByIdListComments, idPost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostByIdListCommentsRow
	for rows.Next() {
		var i PostByIdListCommentsRow
		if err := rows.Scan(
			&i.IDComment,
			&i.ParentID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Comment,
			&i.UserName,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const postsFullTextSearch = `-- name: PostsFullTextSearch :many
SELECT
posts.id_post,
posts.title,
posts.link,
posts.text,
posts.created_at,
posts.updated_at,
users.user_name,
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = TRUE AND scores.id_post = posts.id_post) -
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = FALSE AND scores.id_post = posts.id_post)
AS score
FROM reddit_clone.posts AS posts
JOIN (reddit_clone.users AS users)
ON (users.id_user = posts.id_user)
WHERE MATCH (posts.title, posts.text)
AGAINST (? IN NATURAL LANGUAGE MODE)
`

type PostsFullTextSearchRow struct {
	IDPost    int32      `json:"id_post"`
	Title     string     `json:"title"`
	Link      *string    `json:"link"`
	Text      *string    `json:"text"`
	CreatedAt time.Time  `json:"created_at"`
	UpdatedAt *time.Time `json:"updated_at"`
	UserName  string     `json:"user_name"`
	Score     int32      `json:"score"`
}

func (q *Queries) PostsFullTextSearch(ctx context.Context) ([]PostsFullTextSearchRow, error) {
	rows, err := q.db.QueryContext(ctx, postsFullTextSearch)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostsFullTextSearchRow
	for rows.Next() {
		var i PostsFullTextSearchRow
		if err := rows.Scan(
			&i.IDPost,
			&i.Title,
			&i.Link,
			&i.Text,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const subredditByIdListPostsSortNewestKeySetPaginated = `-- name: SubredditByIdListPostsSortNewestKeySetPaginated :many
SELECT
posts.id_post,
posts.title,
posts.link,
posts.created_at,
posts.updated_at,
users.user_name,
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = TRUE AND scores.id_post = posts.id_post) -
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = FALSE AND scores.id_post = posts.id_post)
AS score,
(SELECT COUNT(*) FROM reddit_clone.comments WHERE comments.id_post = posts.id_post)
as comments_count
FROM reddit_clone.posts AS posts
JOIN (reddit_clone.users AS users)
ON (users.id_user = posts.id_user)
WHERE posts.id_subreddit = ? AND posts.id_post < ? 
ORDER BY posts.id_post DESC
LIMIT 30
`

type SubredditByIdListPostsSortNewestKeySetPaginatedParams struct {
	IDSubreddit int32 `json:"id_subreddit"`
	IDPost      int32 `json:"id_post"`
}

type SubredditByIdListPostsSortNewestKeySetPaginatedRow struct {
	IDPost        int32      `json:"id_post"`
	Title         string     `json:"title"`
	Link          *string    `json:"link"`
	CreatedAt     time.Time  `json:"created_at"`
	UpdatedAt     *time.Time `json:"updated_at"`
	UserName      string     `json:"user_name"`
	Score         int32      `json:"score"`
	CommentsCount int64      `json:"comments_count"`
}

func (q *Queries) SubredditByIdListPostsSortNewestKeySetPaginated(ctx context.Context, arg SubredditByIdListPostsSortNewestKeySetPaginatedParams) ([]SubredditByIdListPostsSortNewestKeySetPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, subredditByIdListPostsSortNewestKeySetPaginated, arg.IDSubreddit, arg.IDPost)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubredditByIdListPostsSortNewestKeySetPaginatedRow
	for rows.Next() {
		var i SubredditByIdListPostsSortNewestKeySetPaginatedRow
		if err := rows.Scan(
			&i.IDPost,
			&i.Title,
			&i.Link,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
			&i.Score,
			&i.CommentsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const subredditByIdListPostsSortNewestStart = `-- name: SubredditByIdListPostsSortNewestStart :many
SELECT
posts.id_post,
posts.title,
posts.link,
posts.created_at,
posts.updated_at,
users.user_name,
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = TRUE AND scores.id_post = posts.id_post) -
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = FALSE AND scores.id_post = posts.id_post)
AS score,
(SELECT COUNT(*) FROM reddit_clone.comments WHERE comments.id_post = posts.id_post)
as comments_count
FROM reddit_clone.posts AS posts
JOIN (reddit_clone.users AS users)
ON (users.id_user = posts.id_user)
WHERE posts.id_subreddit = ?
ORDER BY posts.id_post DESC
LIMIT 30
`

type SubredditByIdListPostsSortNewestStartRow struct {
	IDPost        int32      `json:"id_post"`
	Title         string     `json:"title"`
	Link          *string    `json:"link"`
	CreatedAt     time.Time  `json:"created_at"`
	UpdatedAt     *time.Time `json:"updated_at"`
	UserName      string     `json:"user_name"`
	Score         int32      `json:"score"`
	CommentsCount int64      `json:"comments_count"`
}

func (q *Queries) SubredditByIdListPostsSortNewestStart(ctx context.Context, idSubreddit int32) ([]SubredditByIdListPostsSortNewestStartRow, error) {
	rows, err := q.db.QueryContext(ctx, subredditByIdListPostsSortNewestStart, idSubreddit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubredditByIdListPostsSortNewestStartRow
	for rows.Next() {
		var i SubredditByIdListPostsSortNewestStartRow
		if err := rows.Scan(
			&i.IDPost,
			&i.Title,
			&i.Link,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
			&i.Score,
			&i.CommentsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const subredditByIdListPostsSortScoreHighest = `-- name: SubredditByIdListPostsSortScoreHighest :many
SELECT
posts.id_post,
posts.title,
posts.link,
posts.created_at,
posts.updated_at,
users.user_name,
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = TRUE AND scores.id_post = posts.id_post) -
(SELECT COUNT(*) FROM reddit_clone.scores WHERE scores.score = FALSE AND scores.id_post = posts.id_post)
AS score,
(SELECT COUNT(*) FROM reddit_clone.comments WHERE comments.id_post = posts.id_post)
as comments_count
FROM reddit_clone.posts AS posts
JOIN (reddit_clone.users AS users)
ON (users.id_user = posts.id_user)
WHERE posts.id_subreddit = ?
ORDER BY score DESC
LIMIT 30 OFFSET ?
`

type SubredditByIdListPostsSortScoreHighestParams struct {
	IDSubreddit int32 `json:"id_subreddit"`
	Offset      int32 `json:"offset"`
}

type SubredditByIdListPostsSortScoreHighestRow struct {
	IDPost        int32      `json:"id_post"`
	Title         string     `json:"title"`
	Link          *string    `json:"link"`
	CreatedAt     time.Time  `json:"created_at"`
	UpdatedAt     *time.Time `json:"updated_at"`
	UserName      string     `json:"user_name"`
	Score         int32      `json:"score"`
	CommentsCount int64      `json:"comments_count"`
}

func (q *Queries) SubredditByIdListPostsSortScoreHighest(ctx context.Context, arg SubredditByIdListPostsSortScoreHighestParams) ([]SubredditByIdListPostsSortScoreHighestRow, error) {
	rows, err := q.db.QueryContext(ctx, subredditByIdListPostsSortScoreHighest, arg.IDSubreddit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubredditByIdListPostsSortScoreHighestRow
	for rows.Next() {
		var i SubredditByIdListPostsSortScoreHighestRow
		if err := rows.Scan(
			&i.IDPost,
			&i.Title,
			&i.Link,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserName,
			&i.Score,
			&i.CommentsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const subredditByUrlDetails = `-- name: SubredditByUrlDetails :one


SELECT subreddits.id_subreddit, subreddits.name, subreddits.description, users.user_name
FROM reddit_clone.subreddits AS subreddits
JOIN (reddit_clone.users AS users)
ON (users.id_user = subreddits.id_user)
WHERE subreddits.url = ?
`

type SubredditByUrlDetailsRow struct {
	IDSubreddit int32   `json:"id_subreddit"`
	Name        string  `json:"name"`
	Description *string `json:"description"`
	UserName    string  `json:"user_name"`
}

// Client:
// vis i realtid hvordan det lowercasede subreddit url kommer til at se ud imens du skriver display navnet
// -------------------------------------------------- --
// Subreddits
func (q *Queries) SubredditByUrlDetails(ctx context.Context, url string) (SubredditByUrlDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, subredditByUrlDetails, url)
	var i SubredditByUrlDetailsRow
	err := row.Scan(
		&i.IDSubreddit,
		&i.Name,
		&i.Description,
		&i.UserName,
	)
	return i, err
}

const voteOnComment = `-- name: VoteOnComment :execresult
INSERT INTO reddit_clone.scores (
    score, id_comment, id_user
) VALUES (
    ?, ?, ?
)
`

type VoteOnCommentParams struct {
	Score     bool   `json:"score"`
	IDComment *int32 `json:"id_comment"`
	IDUser    int32  `json:"id_user"`
}

func (q *Queries) VoteOnComment(ctx context.Context, arg VoteOnCommentParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, voteOnComment, arg.Score, arg.IDComment, arg.IDUser)
}

const voteOnPost = `-- name: VoteOnPost :execresult

INSERT INTO reddit_clone.scores (
    score, id_post, id_user
) VALUES (
    ?, ?, ?
)
`

type VoteOnPostParams struct {
	Score  bool   `json:"score"`
	IDPost *int32 `json:"id_post"`
	IDUser int32  `json:"id_user"`
}

// -------------------------------------------------- --
// Scores
func (q *Queries) VoteOnPost(ctx context.Context, arg VoteOnPostParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, voteOnPost, arg.Score, arg.IDPost, arg.IDUser)
}
